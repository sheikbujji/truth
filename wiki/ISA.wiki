#summary Instruction Set Architecture

= Introduction =

 Supported instructions are:

 - Arithmetic Instructions: ADD, SUB
 - Logical Instructions: AND, OR, XOR, NOR
 - Shift Instructions: SLL (Shift left logical), SRI, SLLI (Shirt left logical imm), SRA (Shift right arith), SRLI
 - Compare Instructions: EQ (Compare EQ), LT, LE, LT, 
 - Reg Move: Move 
 - Memory: Load, Store
 - Cond. Breach: BEQ, BNE, BE, BNZ, BLT, BGT, BLE, BGE, RET 
 - Uncond Jump: JMP
 - Atomic: SWAP
 - SW Interrupt: TRAP, IRET

= Details =

 * Can we remove arith(unsigned, imm, or carry)? Let assume we provide an illusion that the supported integer variable type has infinite range. In practice, a fixed memory size (most likely by default 4bytes) is used and when value overflow occurs while performing an arithmetic operation, an exception is issued and the memory size is enlarged accordingly? For non-arithmetic operations (e.g., logical ops), maybe different more explicit (similar to what modern processors have) illusion can be provided. 
 
   What are their other tradeoffs?


   Is small number of instruction good for fault-tolerance? Hardware status could be easy to monitor? What instructions are easier to monitor (e.g., input and output dependencies)?