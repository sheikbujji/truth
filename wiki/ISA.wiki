#summary Instruction Set Architecture

 ====Instructions====

  * Arith/Integer: ADD, SUB, MUL, DIV, MOD, NEG, ABS
  * Logical: AND, OR, XOR, NOR
  * Shift: SLI (Shift left with imm), SRI (Shirt right imm)
  * Compare: EQ, NE, LT, GT, LE, GE
  * Reg-to-Reg Move: Move
  * Memory: Load, Store
  * Stack: Push, Pop
  * Breach: BEQ, BNE, BNE, BNZ, BLT, BGT, BLE, BGE
  * Jump: JMP
  * Atomic: SWAP
  * SW Interrupt: TRAP, IRET

 ====Registers====

  * Control: PC, SP, LR, FLAG
  * General-purpose: D0, ..., D7

 ====Interrupt====
 

 ====Notes====

 * Can we remove arith(unsigned, imm, or carry)? Let assume we provide an illusion that the supported integer variable type has infinite range. In practice, a fixed memory size (most likely by default 4bytes) is used and when value overflow occurs while performing an arithmetic operation, an exception is issued and the memory size is enlarged accordingly? For non-arithmetic operations (e.g., logical ops), maybe different more explicit (similar to what modern processors have) illusion can be provided. 
 
   What are their other tradeoffs?


   Is small number of instruction good for fault-tolerance? Hardware status could be easy to monitor? What instructions are easier to monitor (e.g., input and output dependencies)?